<!doctype html>
<html lang="en">
<head>
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link rel="stylesheet" type="text/css" media="all" href="css/reset.css" /> <!-- reset css -->
<script type="text/javascript" src="http://code.jquery.com/jquery.min.js"></script>
<!-- Bootstrap CSS -->
<!-- <link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous"> -->
<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" crossorigin="anonymous">
<link href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN" crossorigin="anonymous">

<style>
    body{ background-color: ivory; }
    #canvas{border:1px solid red;}
    div.sticky {
      position: -webkit-sticky;
      position: sticky;
      top: 0;
      padding: 30px;
    }
</style>

<script>

var PLAYER_COLOR = '#00ff00'
var MONSTER_COLOR = '#ff0000'
var OBSTACLE_COLOR = '#ff9933'

var canvas=null;
var ctx=null;
var offsetX=null;
var offsetY=null;
var WIDTH = null;
var HEIGHT = null;
var TOKEN_SIZE = null;

// drag related variables
var dragok = false;
var gridOn = false;
var fakeEntity = null;
var startX;
var startY;
var selectors = null;
var selectorIndex = 0;
var selectorFunction = null;
var selected = [];

// an array of objects that define different rectangles
var rects=null;

// draw a single rect
function rect(x,y,w,h) {
    ctx.beginPath();
    ctx.rect(x,y,w,h);
    ctx.closePath();
    ctx.fill();
}

// clear the canvas
function clear() {
    ctx.clearRect(0, 0, WIDTH, HEIGHT);
}

function componentToHex(c) {
  var hex = c.toString(16);
  return hex.length == 1 ? "0" + hex : hex;
}

function rgbToHex(c) {
  return "#" + componentToHex(c[0]) + componentToHex(c[1]) + componentToHex(c[2]);
}

function hexToRgb(hex) {
  var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  return result ? [
    parseInt(result[1], 16),
    parseInt(result[2], 16),
    parseInt(result[3], 16)
 ] : null;
}

function scaleColor(color, scaler) {
    var c = hexToRgb(color);
    for (var i=0; i<c.length; i++) {
        c[i] *= scaler;
        c[i] = Math.round(c[i]);
    }
    return rgbToHex(c);
}

// redraw the scene
function draw() {
    clear();
    ctx.fillStyle = "#FAF7F8";
    if (selectors)
        ctx.fillStyle = scaleColor(ctx.fillStyle, 0.7);
    rect(0,0,WIDTH,HEIGHT);

    // draw grid
    if (dragok || gridOn) {
        ctx.fillStyle="#ffffff";
        ctx.lineWidth = 1;
        for (i = TOKEN_SIZE; i < HEIGHT; i += TOKEN_SIZE)
        {
            ctx.moveTo(0, i);
            ctx.lineTo(WIDTH, i);
            ctx.stroke();
        }
        for (i = TOKEN_SIZE; i <WIDTH; i += TOKEN_SIZE)
        {
            ctx.moveTo(i, 0);
            ctx.lineTo(i,HEIGHT);
            ctx.stroke();
        }
    }

    // redraw each rect in the rects[] array
    var fill = "";
    for(var i=0;i<rects.length;i++){
        var r=rects[i];
        fill = r.fill;
        if (selectors && selectors[selectorIndex].indexOf(r.type) < 0)
            fill = scaleColor(fill, 0.5);
        ctx.fillStyle=fill;
        rect(r.x,r.y,r.size*TOKEN_SIZE,r.size*TOKEN_SIZE);
    }

    if (fakeEntity && fakeEntity.col && fakeEntity.row) {
        // fakeEntity.icon.onload = function() {
        //   ctx.drawImage(fakeEntity.icon, fakeEntity.x, fakeEntity.y);
        // };
        ctx.fillStyle=fakeEntity.fill;
        rect(fakeEntity.x, fakeEntity.y, fakeEntity.size*TOKEN_SIZE, fakeEntity.size*TOKEN_SIZE)
    }
}

function pullGrid() {
    $.ajax({
        url: "/grid",
        type: "GET",
        contentType: "application/json"}).done(function(data) {
            var parsed = JSON.parse(data);
            rects = parsed
            for (var i=0;i<rects.length;i++) {
                rects[i].x = rects[i].col * TOKEN_SIZE;
                rects[i].y = rects[i].row * TOKEN_SIZE;
                rects[i].isDragging = false;
                if (rects[i].type == 'player')
                    rects[i].fill = PLAYER_COLOR;
                else if (rects[i].type == 'monster')
                    rects[i].fill = MONSTER_COLOR;
                else if (rects[i].type == 'obstacle')
                    rects[i].fill = OBSTACLE_COLOR;
            }
            // call to draw the scene
            draw();
    });
}

function rectHover(mx, my) {

    for(var i=0;i<rects.length;i++){
        var r=rects[i];
        if(mx>r.x && mx<r.x+r.size*TOKEN_SIZE && my>r.y && my<r.y+r.size*TOKEN_SIZE){
            // if yes, set that rects isDragging=true
            return r;
        }
    }
}

// handle mousedown events
function myDown(e){

    // tell the browser we're handling this mouse event

    e.preventDefault();
    e.stopPropagation();

    // get the current mouse position

    var mx=parseInt(e.clientX-offsetX);
    var my=parseInt(e.clientY-offsetY);

    // test each rect to see if mouse is inside
    var r = rectHover(mx, my);
    if (r != undefined) {
        dragok=true;
        r.isDragging=true;
    }

    // save the current mouse position
    startX=mx;
    startY=my;
}

// handle mouseup events
function myUp(e){
    // tell the browser we're handling this mouse event
    e.preventDefault();
    e.stopPropagation();

    // clear all the dragging flags
    dragok = false;
    changeMade = false;
    for(var i=0;i<rects.length;i++){
        if (rects[i].isDragging) {
            var r=rects[i];
            r.col = snapToGrid(r.x);
            r.x = TOKEN_SIZE * r.col;
            r.row = snapToGrid(r.y);
            r.y = TOKEN_SIZE * r.row;

            $.ajax({
                url: "/update/pos/" + [r.eid, r.col, r.row].join('/'),
                type: "GET"});
            changeMade = true;
        }
        rects[i].isDragging=false;
    }
    if (changeMade)
        draw();
}

function snapToGrid(p) {
    var div = p / TOKEN_SIZE;
    var offset = div % 1;
    if (offset < 0.5) {
        return Math.floor(div);
    } else {
        return Math.ceil(div);
    }
}


// handle mouse moves
function moveEntity(e){
    // if we're dragging anything...
    if (dragok){

        // tell the browser we're handling this mouse event
        e.preventDefault();
        e.stopPropagation();

        // get the current mouse position
        var mx=parseInt(e.clientX-offsetX);
        var my=parseInt(e.clientY-offsetY);

        // calculate the distance the mouse has moved
        // since the last mousemove
        var dx=mx-startX;
        var dy=my-startY;

        // move each rect that isDragging
        // by the distance the mouse has moved
        // since the last mousemove
        for(var i=0;i<rects.length;i++){
            var r=rects[i];
            if(r.isDragging){
                r.x+=dx;
                r.y+=dy;
            }
        }

        // redraw the scene with the new rect positions
        draw();

        // reset the starting mouse position for the next mousemove
        startX=mx;
        startY=my;

    }
}

function selectEntity(e) {
    // tell the browser we're handling this mouse event
    e.preventDefault();
    e.stopPropagation();

    // get the current mouse position
    var mx=parseInt(e.clientX-offsetX);
    var my=parseInt(e.clientY-offsetY);

    var r = rectHover(mx, my);
    if (selectors[selectorIndex].indexOf(r.type) >=0) {
        selected.push(r);

        selectorIndex += 1;
        if (selectorIndex == selectors.length) {
            selectors = null;
            canvas.onmousedown = myDown;
            selectorFunction();
            selected = [];
        }
    }
    draw();
}

function placeEntity() {
    $.ajax({
        url: "/create/" + [fakeEntity.type, fakeEntity.col, fakeEntity.row].join('/'),
        type: "GET"}).done(function(data) {
            fakeEntity.eid = data;
            rects.push(fakeEntity);
            fakeEntity = null;
    });
    gridOn = false;
    canvas.onmousemove = moveEntity;
    canvas.onmousedown = myDown;

    draw();
}

function showFakeEntity(e) {
    // tell the browser we're handling this mouse event
    e.preventDefault();
    e.stopPropagation();

    // get the current mouse position
    var mx=parseInt(e.clientX-offsetX);
    var my=parseInt(e.clientY-offsetY);

    mx -= fakeEntity.size * TOKEN_SIZE / 2;
    my -= fakeEntity.size * TOKEN_SIZE / 2;

    // calculate the distance the mouse has moved
    // since the last mousemove
    // var dx=mx-startX;
    // var dy=my-startY;

    fakeEntity.col = snapToGrid(mx);
    fakeEntity.x = TOKEN_SIZE * fakeEntity.col;
    fakeEntity.row = snapToGrid(my);
    fakeEntity.y = TOKEN_SIZE * fakeEntity.row;

    // redraw the scene with the new rect positions
    draw();

    // reset the starting mouse position for the next mousemove
    // startX=mx;
    // startY=my;
}

function addEntity(type, color) {
    // need to:
    // 1. replace the on click function to add player on click
    // var imgObj = new Image();
    canvas.onmousedown = placeEntity;
    // imgObj.src = "https://dantheletsplayman.files.wordpress.com/2012/02/ash-red.png"
    // 2. show the grid
    gridOn = true;
    // 3. show a transparent player show up on the grid
    fakeEntity = {"col":null, "row":null, "size":1,"fill":color, "type": type};
    canvas.onmousemove = showFakeEntity;
}

function animateMovement(entity, path) {
    if (path.length == 0)
        return

    var position = path.pop();
    entity.x = position[0]*TOKEN_SIZE;
    entity.y = position[1]*TOKEN_SIZE;
    draw();
    setTimeout(animateMovement.bind(null, entity, path), 1000/4);
}

function giveEntityTurn(entity) {
    $.ajax({
        url: "/pathfind/" + entity.eid,
        type: "GET",
        async: false}).done(function(data) {
            animateMovement(entity, JSON.parse(data));
    });
}

function turn() {
    for (var i=0;i<rects.length;i++) {
        if (rects[i]['type'] == "monster") {
            giveEntityTurn(rects[i]);
        }
    }
}

function propagateDamage() {
    var damage = parseInt(prompt("How much damage?", "15"));

    $.ajax({
        url: "/damage/" + [selected[0].eid, selected[1].eid, damage].join('/'),
        type: "GET"}).done(function(data) {
            // If monster dies, remove it.
    });
}

function propagateHeal() {
    var heal = parseInt(prompt("How much to heal?", "15"));

    $.ajax({
        url: "/heal/" + [selected[0].eid, heal].join('/'),
        type: "GET"});
}

function propagateStatCheck() {
    var stat = prompt("What stat to check?", "Athletics");

    (function(eid, stat) {
        // you can use the variable "index" here instead of i
        $.ajax({
        url: "/check/" + [eid, stat.toLowerCase()].join('/'),
        type: "GET"}).done(function(data) {
            if (data == "0")
                data = "Invalid request. Options include: [attack, ac, damage, stats, athletics, etc.]"
            else if (data.indexOf(eid) != -1)
                data = data.substr(data.indexOf(eid) + eid.length+1);
            alert(data);
        },
        async = false);
    })(selected[0].eid, stat);

}

function propagateRemove() {
    $.ajax({
        url: "/remove/" + selected[0].eid,
        type: "GET"}).done(function(data) {
            pullGrid();
    });
}

function damage() {
    selectors = [['player'], ['monster']];
    selectorIndex = 0;
    selectorFunction = propagateDamage;
    canvas.onmousedown = selectEntity;

    draw();
}

function heal() {
    selectors = [['player', 'monster']];
    selectorIndex = 0;
    selectorFunction = propagateHeal;
    canvas.onmousedown = selectEntity;

    draw();
}

function checkStat() {
    selectors = [['monster']];
    selectorIndex = 0;
    selectorFunction = propagateStatCheck;
    canvas.onmousedown = selectEntity;

    draw();
}

function remove() {
    selectors = [['monster', 'player', 'obstacle']];
    selectorIndex = 0;
    selectorFunction = propagateRemove;
    canvas.onmousedown = selectEntity;

    draw();
}

window.onload=function(){

    // get canvas related references
    canvas=document.getElementById("canvas");
    ctx=canvas.getContext("2d");
    var BB=canvas.getBoundingClientRect();
    offsetX=BB.left;
    offsetY=BB.top;
    WIDTH = canvas.width;
    HEIGHT = canvas.height;
    TOKEN_SIZE = Math.min(WIDTH, HEIGHT)/15;

    // listen for mouse events
    canvas.onmousedown = myDown;
    canvas.onmouseup = myUp;
    canvas.onmousemove = moveEntity;

    pullGrid();

}; // end $(function(){});
</script>
</head>
<body>
  <div class="row">
    <div class="col">
      <canvas id="canvas" width=500 height=500></canvas>
      <script src='/js/canvas.js'></script>
      <div align="center">
        <a href="#" onclick="addEntity('player', PLAYER_COLOR)" class="btn btn-primary"><span class="fa fa-user"></span> Add Player </a>
        <a href="#" onclick="addEntity('monster', MONSTER_COLOR)" class="btn btn-secondary"><span class="fa fa-flash"></span> Add Monster </a>
        <a href="#" onclick="addEntity('obstacle', OBSTACLE_COLOR)" class="btn btn-warning"><span class="fa fa-fire"></span> Add Obstacle </a>
        <a href="#" onclick="remove()" class="btn btn-danger"><span class="fa fa-remove"></span> Remove </a>
    </div>
    </div>
    <div class="col">
      <div class="sticky">
        <div class="btn-group-vertical">
          <button type="button" onClick="damage()" class="btn btn-danger">Damage</button>
          <button type="button" onClick="heal()" class="btn btn-success">Heal</button>
          <button type="button" onClick="checkStat()" class="btn btn-warning">Check Stats</button>
          <button type="button" onClick="turn()" class="btn btn-info">Start Monster Turn</button>
        </div>
      </div>
    </div>
  </div>

</body>
</html>
